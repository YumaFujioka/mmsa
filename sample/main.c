/* 
 *	このプログラムは, あらかじめ与えられた画像パターン(以下この画像の
 *	ことをテンプレート画像と呼びます)を, 別の大きな画像(以下この画像のこと
 *	を探索対象画像と呼びます)から探します. 見付かった結果は, 探索対象画像の
 *	上にテンプレート画像の外枠に相当する長方形を重ね書きすることで, 
 *	見えるようにします. 
 *
 *	画像は, netpbm (pbmplus) で用いられるカラー画像フォーマット `ppm' を
 *	用いています. 
 *
 */
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <ctype.h>
#include "pnmimg.h"
#include <time.h>




#ifdef __STDC__
int
main( int argc, char *argv[] )
#else
int
main( argc, argv )
     int argc ;
     char *argv[] ;
#endif
{
  /*
   *  このプログラムは３つのコマンドライン引数を指定して動作します.
   *  第１の引数は, テンプレートの画像ファイル(PPM フォーマット)であり,
   *  第２の引数は, 探索対象画像のファイルです. 引数が省略された場合には,
   *  第１引数の代わりに "template.ppm" という名前が, 第２引数の代わりに
   *  "image.ppm" という名前が用いられます.
   *  更に, 第３の引数を指定すると, 探索結果を出力する画像ファイルの
   *  名前を指定することも出来ます. 指定しなければ, "result.ppm" という
   *  名前が用いられます.
   */
  clock_t start,end;//時間計測
  start = clock();

  char *name_tmp = "template.ppm" ;
  char *name_img = "image.ppm" ;
  char *name_out = "result.ppm" ;
  RGB_PACKED_IMAGE *template ;
  RGB_PACKED_IMAGE *image ;
  double cx, cy, rotation, scaling ;
  int icx, icy, irot, isx, isy ;
  int ret ;
  extern int findPattern __P(( RGB_PACKED_IMAGE*, RGB_PACKED_IMAGE*, double*, double*, double*, double* )) ;
  extern RGB_PACKED_IMAGE* zoomreduction(RGB_PACKED_IMAGE*,double);
  extern RGB_PACKED_IMAGE* rota(RGB_PACKED_IMAGE*,int);

  if ( argc > 1 ) name_tmp = argv[1] ;
  if ( argc > 2 ) name_img = argv[2] ;
  if ( argc > 3 ) name_out = argv[3] ;

  if (!( template = readRGBPackedImage( name_tmp ))) {
    printError( name_tmp ) ;
    return(1) ;
  }
  if (!( image = readRGBPackedImage( name_img ))) {
    printError( name_img ) ;
    return(1) ;
  }

  /*
   *  ２枚の画像が読み込まれました. ここから, これらの画像を
   *  パターンを探索する関数 findPattern() に渡して,
   *  探索を行います. 結果は見付かったテンプレートの画像の
   *  中心の座標 ( cx, cy ) とテンプレートの回転角 rotation,
   *  および拡大/縮小率 scaling とに入れて, 返されます. これらの
   *  変数は double 表現です. また, scaling は見付けたパターンの
   *  大きさとテンプレートの大きさとの比で表現し, rotation は
   *  画面に対して反時計周りを正とする degree (度)単位で表現します.
   *  この関数は, うまく見付かった時に NO_ERROR (0) を返し,
   *  そうでなければ HAS_ERROR (-1) を返すようになっています.
   */



  //template = rota(template,20);//回転する
  //template = zoomreduction(template,1.5); //拡大縮小する

  ret = findPattern( template, image, 
          &cx, &cy, &rotation, &scaling ) ;
  if ( ret == HAS_ERROR ) {
    printError( "findPattern" ) ;
    printf( "%s is failed to be searched in %s\n", name_tmp, name_img ) ;
    return(1);
  }
  else{
    printf("NO_ERROR\n");
  }
  /*
   *  探索した結果を元の探索画像の上に長方形の枠で表示します.
   */
  icx = (int)( cx + .5 ) ;
  icy = (int)( cy + .5 ) ;
  isx = (int)( scaling * template->cols + .5 ) ;
  isy = (int)( scaling * template->rows + .5 ) ;
	/*
  isx = (int)( template->cols + .5 ) ;
  isy = (int)( template->rows + .5 ) ;
	*/
  irot = (int)( rotation + .5 ) ;
  setRGBMarkColor( 255, 255, 0 ) ;
  drawRotatedRectangleRGBPackedImage( image, icx, icy, isx, isy, irot ) ;

  /*
   *  結果を端末に出力し, 画像をファイルにセーブします.
   */
  printf( "%s is successfully searched in %s\n", name_tmp, name_img ) ;
  printf( "location (%5.1lf,%5.1lf), rotation %6.1lf, scaling %4.2lf\n",
	  cx, cy, rotation, scaling ) ;



  if ( writeRGBPackedImage( image, name_out ) == HAS_ERROR ) {
    printError( name_out ) ;
    end = clock();//時間計測
    printf("processing time:%.2fsec\n",(double)(end-start)/CLOCKS_PER_SEC);
    return(1) ;
  }
  printf( "result image is saved in %s\n", name_out ) ;

  end = clock();//時間計測
  printf("processing time:%.2fsec\n",(double)(end-start)/CLOCKS_PER_SEC);


  //level1
  double usagi_1[2] = {50, 170};
  double inu_1[2] = {140, 175};
  double reoinu_1[2] = {300, 65};
  double tamago_1[2] = {260, 175};
  double yuurei_1[2] = {100, 60};
  double pengin_1[2] = {50, 170};
  double neko_1[2] = {145, 175};
  double saru_1[2] = {300, 65};
  double saboten_1[2] = {260, 175};
  double usamimi_1[2] = {70, 60};
  double usamimi2_1[2] = {200, 80};

  //level2
  double reoinu_2[3] = {50, 180, 0.9};
  double inu_2[3] = {80, 60, 1.1};
  double usagi_2[3] = {150, 170, 0.8};
  double usamimi_2[3] = {260, 150, 1.3};
  double usamimi2_2[3] = {200, 50, 0.7};
  double tamago_2[3] = {55, 170, 0.9};
  double pengin_2[3] = {80, 50, 1.1};
  double saboten_2[3] = {140, 200, 0.8};
  double neko_2[3] = {275, 160, 1.3};
  double saru_2[3] = {285, 50, 0.7};
  double yuurei_2[3] = {175, 85, 1.0};

  //level3
  double usagi_3[4] = {65, 121, 0.8, 11};
  double neko_3[4] = {246, 143, 1.1, 17};
  double reoinu_3[4] = {175, 145, 1.4, -12};
  double tamago_3[4] = {200, 67, 0.6, -25};
  double usamimi2_3[4] = {70, 65, 1.2, 16};
  double pengin_3[4] = {292, 153, 0.9, -18};
  double saru_3[4] = {111, 91, 1.6, -25};
  double inu_3[4] = {65, 151, 0.8, 11};
  double usamimi_3[4] = {250, 92, 1.0, -6};
  double yuurei_3[4] = {111, 170, 1.3, -5};
  double saboten_3[4] = {171, 162, 0.8, 14};


  return(0) ;
}
